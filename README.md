# CompSec
Статья.
1) Какую проблему решает эта статья?

Использование паролей и необходимость их защиты никуда не делись. Большинство веб-сайтов, требующих аутентификации, продолжают поддерживать аутентификацию по паролю. Даже высокозащищенные приложения, такие как порталы интернет-банкинга, которые развертывают 2-факторную аутентификацию, полагаются на аутентификацию паролем в качестве одного из факторов аутентификации. Однако фишинговые атаки продолжают мешать аутентификации на основе паролей, несмотря на агрессивные усилия по обнаружению и уничтожению, а также комплексные программы повышения осведомленности пользователей и обучения. В настоящее время нет надежного механизма даже для веб-сайтов, заботящихся о безопасности, чтобы предотвратить перенаправление пользователей на мошеннические веб-сайты и фишинг их паролей.
В этой статье мы применяем анализ угроз в процессе создания веб-пароля и обнаруживаем уязвимость дизайна в поле HTML <input type="password">. Эта уязвимость может быть использована для фишинговых атак, поскольку процесс веб-аутентификации не полностью защищен от каждого поля ввода пароля на веб-сервере. В статье определяются четыре свойства, которые инкапсулируют требования для предотвращения веб-фишинга паролей, и предлагается безопасный протокол для использования с новым полем учетных данных, соответствующим этим четырем свойствам.

-	Идентификация — это заявление о том, кем вы являетесь. В зависимости от ситуации, это может быть имя, адрес электронной почты, номер учетной записи, итд.
-	Аутентификация — предоставление доказательств, что вы на самом деле есть тот, кем идентифицировались (от слова “authentic” — истинный, подлинный).
-	Авторизация — проверка, что вам разрешен доступ к запрашиваемому ресурсу.
-	Фишинг - Злоумышленник копирует исходный код страницы, к примеру, авторизации почтового сервиса, и загружает на свой арендованный хостинг, где он, само собой, разместил свои фиктивные данные. Затем он создает адрес этой страницы очень похожий на оригинальный.Также фиктивная страница настроена так, что после ввода данных (логина и пароля) они сохраняются на сайте хакера. Этот метод основывается на том, что пользователь должен предоставить username и password для успешной идентификации и аутентификации в системе. Пара username/password задается пользователем при его регистрации в системе, при этом в качестве username может выступать адрес электронной почты пользователя.

2) Как определяется безопасность? Какой же противник предполагается?

Противник, с которым мы имеем дело, - это фишинговый злоумышленник с целью успешной аутентификации на честном веб-сервере от имени пользователя (то есть, в частности, противник заинтересован в краже учетных данных пользователей). Мы предполагаем, что противник способен:
- Обман пользователя, чтобы посетить фишинговый веб-сервер под контролем противника.
- Считывает все данные передачи, отправленные из браузера пользователя.
- Прочитайте все данные, хранящиеся в хранилище учетных данных честного веб-сервера.
Далее мы предполагаем, что противник не заинтересован в атаках типа "отказ в обслуживании"; программное обеспечение браузера, работающее на устройстве пользователя, не скомпрометировано; сеанс входа в систему проходит по защищенному каналу (например, TLS), и противник не имеет доступа на запись к честному веб-серверу или хранилищу учетных данных.
3) Варианты использования пароля для Входа в систему
Мы определяем удаленную веб - систему аутентификации паролей как набор одной функции браузера Derive () и двух серверных функций Verify() и Store (), чтобы выполнить следующие варианты использования:
1. Зачисление Пароль. Это делается для того, чтобы помочь пользователю, который является новичком в системе или забыл свой пароль. В этом случае пользователю предлагается ввести самостоятельно выбранный пароль достаточной длины и сочетания символов,и этот выбранный пароль сохраняется в производной форме для последующей проверки.
- В интерфейсе браузера мы определяем функцию Derive (), где
Derive (идентификато пользователя; пароль)-> Cred   (1)
преобразует входной пароль в формат учетных данных, который будет получен веб-сервером.
- В серверной части мы определяем хранилище функций Store(Cred) -> output, который преобразует полученные учетные данные в вывод для долгосрочного хранения. Хранилище учетных данных CredDB будет обновлено до CredDBnew. Регистрация пароля определяется следующим образом:
CredDBnew = CredDB  ∪ Store(Cred) (2)
2. Повторите Ввод Пароля Для Проверки. Это наиболее часто используемый вариант использования, когда сервер должен аутентифицировать ранее зарегистрированного пользователя, который представляет свои данные ранее выбранный пароль.
- В интерфейсе браузера та же функция Derive () (1) используется для преобразования пароля в учетные данные для проверки сервера.
- В серверной части мы определяем функцию Verify (), которая возвращает true, если полученные учетные данные соответствуют ранее зарегистрированному паролю. Проверка пароля определяется как:
Verify (Cred) -> true => Store (Cred) ∈ CredDB (3)
3. Смена Пароля. Это делается для того, чтобы пользователь мог заменить свой выбранный пароль новым паролем либо на регулярной, либо на специальной основе. Процесс изменения пароля требует, чтобы пользователь представил как существующий пароль, так и вновь выбранный пароль, и операция по существу представляет собой комбинацию проверки существующего пароля и регистрации вновь выбранного пароля.
- В интерфейсе браузера мы применяем одну и ту же функцию Derive () (1) как к существующему, так и к новому паролю, получая Cred и Crednew для поддержки процесса смены пароля.
- В серверной части мы аутентифицируем существующий пароль с помощью
функции Verify () перед обновлением хранилища учетных данных CredDB
новыми выбранными учетными данными. Смена пароля определяется следующим образом:
Verify (Cred) -> true =>
CredDB new = (CredDB \ Store(Cred)) ∪ Store (Crednew) (4)
После определения вариантов использования мы можем приступить к оценке угроз. Цель состоит в том, чтобы понять, почему фишинг паролей продолжает происходить, несмотря на все усилия, и каковы конкретные требования, которые должны быть выполнены для того, чтобы устранить фишинг паролей.
4)Оценка Угроз
Одна из уязвимостей заключается в конструкции поля ввода пароля при обработке пароля. В настоящее время поле ввода пароля маскирует ввод пользователя с дисплея, гарантируя, что информация, введенная в это поле, не может быть видна пользователю или кому-либо физически находящемуся перед экраном вместе с пользователем. Однако, когда мы исследуем в браузере, содержимое указанного поля доступно для любых вредоносных компонентов (например, Javascript) в открытом виде на HTML-странице. Кроме того, при изменении входного параметра поля, пароль передается как часть Html формы на веб-сервер, содержимое поля находится в открытом состоянии, что позволяет связывающемуся веб-серверу получить доступ к его содержимому. Для того, чтобы фишить пароли, злоумышленник должен был бы зарегистрировать доменное имя и создать веб-сайт, который очень похож на реальный сайт. Затем пользователь заманивается на сайт злоумышленника с помощью подменных URL-ссылок и обманом вводит свои учетные данные пароля на поддельную HTML-страницу.Затем эти пароли могут быть воспроизведены столько раз, сколько злоумышленник захочет выдать себя за пользователя. 

Еще одна уязвимость связана с проверкой учетных данных. Простая аутентификация по паролю уязвима для повторных атак, когда учетные данные, отправленные веб-браузером, могут быть повторно отправлены для получения того же уровня доступа. Поскольку эти отправленные учетные данные потенциально могут быть захвачены в журналах аудита или отладки на веб-сервере, мы должны убедиться, что отправленные учетные данные не могут быть повторно использованы для другого входа.

Наконец, входное взаимодействие между Пользователем и браузером - это точка уязвимости где кейлоггеры и другие вредоносные программы могут захватите пароль, когда пользователь вводит его в поле ввода пароля. Злоумышленники могут обмануть пользователей, создав текстовое поле, имитирующее поле ввода пароля, и обманом заставить пользователей вводить свои пароли в текстовое поле. Кроме того, пароль, введенный пользователем, может быть "обнюхан" кейлоггерами. Эта последняя угроза возникает на уровне операционной системы, вне контекста браузера.

Подводя итог выводам об угрозах, становится ясно, что текущая конструкция поля ввода пароля является источником уязвимости для нескольких угроз:
- В браузере любой активный код, например Javascript, имеет доступ к значениям четкого пароля, содержащимся в поле ввода пароля.
- В рамках веб-сеанса любое содержимое пароля, отправленное вместе с HTML-формой на любой веб-сервер, доступно в открытом виде.
- Вне веб-сеанса любой злоумышленник может подделать поддельное поле ввода пароля и, возможно, обмануть конечных пользователей, введя свой пароль в такое поле.
И они должны быть всесторонне рассмотрены, чтобы остановить фишинг.
5) 4 Свойства
Мы начнем с рассмотрения дизайна поля ввода пароля. В статье рекомендуется отказаться от существующей функциональности поля ввода пароля и ввести новое поле ввода учетных данных (например, <input type= "credential"..>) , чтобы предотвратить доступ к необработанным входным данным не только других пользователей, но и любых других активных компонентов или форм на HTML-странице.
HTML-страница. Кроме того, пароль, введенный пользователем-человеком в новое поле ввода учетных данных, никогда не должен быть прочитан или отправлен в открытом виде и вместо этого преобразован в учетные данные с единственной целью одноразовой проверки веб-сервером. В статье объединены требования в следующие четыре свойства:
- Р1 - учетных данных - это односторонняя функция. Когда учетные данные считываются из поля ввода учетных данных для обработки HTML-кода или во время отправки, злоумышленник не может получить пароль из этих учетных данных.
- P2 - одноразовое использование учетных данных. Когда пароль вводится в поле ввода учетных данных, он может быть использован только в это конкретное время, из этого конкретного браузера, для конкретной цели аутентификации конкретного пользователя на конкретном веб-сайте. Знание учетных данных не должно позволять злоумышленнику получать прошлые учетные данные или генерировать будущие учетные данные.
- P3 - односторонняя функция хранения учетных данных. Когда учетные данные отправляются на веб-сайт и хранятся в хранилище учетных данных во время ввода пароля при регистрации или смене пароля злоумышленник не может получить учетные данные из сохраненных учетных данных.
- P4 - Когда поле ввода учетных данных получает пароль от пользователя, оно должно иметь возможность выполнять функцию Derive() неинтерактивно для вывода учетных данных, которые можно использовать как для регистрации, так и для проверки. Учетные данные не должны зависеть ни от каких HTML-состояние или требовать какого-либо обмена протоколами с внешней системой. Это делается для того, чтобы предотвратить использование злоумышленником любых возможных промежуточных состояний между паролем и учетными данными.
6) Стратегия проектирования
- Чтобы соответствовать свойству P1, пароль должен быть автоматически преобразован браузером в односторонние учетные данные как только он будет введен в поле ввода учетных данных. Это лишает любой вредоносный код внутри HTML-страницы или удаленного веб-сервера возможности получить доступ к четкому входному паролю от пользователя.
- Чтобы удовлетворить свойству P2, функция Derive() должна преобразовать входной пароль в проверяемые учетные данные, которые не могут быть повторно использованы, перенаправлены, отменены или атакованы автономным словарем:
-	Чтобы предотвратить повторное использование, учетные данные должны включать метку времени и вызов сеанса.
-	Чтобы предотвратить перенаправление, учетные данные должны включать URL-адрес, скоторого браузер загрузил HTML-страницу.
-	Чтобы предотвратить атаки автономного словаря, функция Derive() должна быть способна защитить низкоэнтропийные пароли (такие как 6-значный pin-код или платежная карта CVV) от грубой силы, угаданной злоумышленником. Наша стратегия состоит в том, чтобы включить аутентификацию браузера в учетные данные.
- Чтобы выполнить свойство P3, Store() функция должна выполнить одностороннюю операцию по преобразованию учетных данных для хранения и использования при последующей проверке пароля.
-  Чтобы соответствовать свойству P4, поле ввода учетных данных в браузере должно выполнять одну и ту же функцию Derive() независимо от того, будет ли входной пароль использоваться для ввода пароля, проверка или изменение.

Для достижения этой цели учетные данные, полученные из входного пароля, должны включать в себя четыре части:
-	Подтверждение знания пароля, введенного в поле ввода учетных данных.
-	 Уникальный идентификатор пароля для хранения во время регистрации или сравнения во время проверки.
-	Доказательство того, что пароль введен в определенном браузере.
-	 Уникальный идентификатор браузера для хранения во время регистрации или сравнения во время проверки.
7) Предлагаемый Протокол
  Используя стратегию, описанную в разделе 6 части, в статье разработан протокол регистрации, проверки и изменения паролей как единый двусторонний обмен информацией, начиная с
   веб-сервера -> Браузер -> Веб-Сервер:
  1.	веб-сервер: получив запрос страницы от браузера, веб-сервер вернет вызов с HTML-страницей.
  2.	 поле ввода учетных данных в браузере: после ввода пароля пользователем
  это поле вызовет функцию Derive () для преобразования пароля в учетные данные для отправки HTML- формы.
  3.	Веб-сервер: при получении учетных данных:
  - Вызовите функцию Store () для преобразования учетных данных для хранения.
  - Обновиляется хранилище учетных данных учетными данными пользователя, если это запрос на проверку пароля:
  - Вызовите Verify (), чтобы проверить действительность учетных данных. Если это запрос на изменение пароля, то вызовите функцию Store (), чтобы преобразовать новые учетные данные для хранения.
  - Замените существующие учетные данные хранилища в хранилище учетных данных
  новыми учетными данными пользователя.
8)сайт сможет предотвратить фишинг паролей с помощью предлагаемого нами поля ввода учетных данных при условии, что существующее поле ввода пароля устарело и веб-сервер работает по протоколу TLS.
9) Заключение.
В статье использовали подход анализа угроз для выявления уязвимости дизайна в процессе ввода веб-пароля. Исходя из этого, и также рекомендовано отказаться от текущего поля ввода пароля <input type="password"> в стандарте HTML и предложить поле ввода учетных данных в сочетании с защищенным протоколом TLS, который может остановить веб-фишинговые атаки при использовании в сочетании с антивирусном программным обеспечением. Тот же самый предлагаемый протокол поддерживает случаи проверки и изменения паролей взаимозаменяемы. Тем не менее, в статье говорится, что предлагаемое изменение не является панацеей для решения всех парольных атак. Социальная инженерия для кражи паролей все еще может происходить в других формах, таких как телефонные мошенники, и плохая "гигиена" паролей все еще позволит мотивированному злоумышленнику поставить под угрозу безопасность паролей системы. Это
предлагаемое решение все еще должно быть дополнено существующими усилиями по обнаружению и удалению, а также постоянной осведомленностью и обучением пользователей, чтобы быть эффективным в устранении случаев успешной компрометации паролей.

